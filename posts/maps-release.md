import MapDemo2d from './maps-release/MapDemo2d'
import MapDemo4d from './maps-release/MapDemo4d'

export const meta = {
  version: '1.0.0',
  title: '@carbonplan/maps',
  authors: ['Jeremy Freeman', 'Kata Martin', 'Joe Hamman'],
  date: '09-24-2021',
  summary: 'A new toolkit for rendering data-driven maps on the web',
}

We've been rendering maps on the web for a long time.

It began in 1995 with the [Xerox Parc Map Viewer](https://en.wikipedia.org/wiki/Xerox_PARC_Map_Viewer), which rendered map images as GIFs generated by a server. In 2005 [Google Maps](​​https://en.wikipedia.org/wiki/Google_Maps) popularized the now widespread paradigm of “tiled map pyramids”, in which the 2d world is divided into tiles, with more tiles at higher resolutions, and the client renders only the tiles that need to be displayed depending on the current location and zoom level, stitching them together like a quilt. Google itself didn't invent the concept of tiled maps — video games were arguably [doing something similar](https://en.wikipedia.org/wiki/Tile-based_video_game) in the 70s and 80s, using tiles to render large worlds while fitting under memory constraints, and multi-scale pyramid representations in signal processing date back even further — but the success of Google Maps helped make tiled maps a standard for the web.

For most of the 2000s, tiled web maps used “raster” tiles — static, pre-generated images, typically 256 x 256 pixels in size. They're fast to load, easy to render, but limited by their fixed resolution, and difficult to manipulate or style interactively on the client, instead requiring server-side regeneration. In the early 2010s [“vector” tiles](https://wiki.openstreetmap.org/wiki/Vector_tiles) were introduced, which store geometry rather than pixels, and can be rendered with [WebGL](https://github.com/KhronosGroup/WebGL) at arbitrarily high resolution and with lots of customizability. Vector tiles quickly became a standard, and the open source [`mapbox-gl-js`](https://github.com/mapbox/mapbox-gl-js) library from Mapbox made it easy to render vector tiles in JavaScript using WebGL, enabling an exciting ecosystem of developers and use cases.

## The problem

As is often the case, scientific use cases push the boundaries of current software.

In many scientific settings — including, but not limited to, climate science — we work with numerical, gridded data arising from simulations, observations, or computational analyses. They can be two-dimensional, like a spatial map of global temperature on a particular day, but they are often multi-dimensional, for example, maps of monthly precipitation (3d), or ocean temperature across depth and time (4d).

It's surprisingly tough to render these data with existing tools.

We can treat them as classic raster tiles, by converting the data into a pixelated image format like PNG or JPEG. But that makes it difficult to dynamically customize the rendering of the data based on user input — which is why the web mapping world moved away from raster tiles in the first place!

Can we treat them as vector tiles instead? We can certainly convert a dense numerical grid to a collection of points, which vector tiles can store and existing tools can work with, including querying and displaying different features per point. That's exactly how we built our [forest risk map](https://carbonplan.org/research/forest-risks). However, there are some significant drawbacks to this approach. First, it requires producing a highly inefficient intermediate format that becomes too big to handle comfortably with high-resolution data. Second, it offers little flexibility for optimizing how we store, fetch, and combine different dimensions of the data, which can matter a lot for performance.

## A solution

We think it's possible to bring the benefits of modern vector-based tiles to multi-dimensional gridded rasters, while tailored to the unique properties of these data. The solution lies in using a new file format well-suited to multi-dimensional tiles, and then using the data in those tiles to render to WebGL directly rather than through an intermediate pixelated image.

First, the file format: [Zarr](https://zarr.readthedocs.io/en/stable/). It's a compressed, binary, chunked format. It's become popular in the scientific Python community, especially alongside the [`Xarray`](http://xarray.pydata.org/) package, but the format itself is rigorously [specified](https://zarr.readthedocs.io/en/stable/spec/v2.html) and files can be read in [many other languages](https://github.com/zarr-developers/zarr_implementations). Zarr is well-suited to tiled maps. The “chunks” of a Zarr dataset — the blocks into which the multi-dimensional array is divided — are analogous to the “tiles” of a web map, except that chunks can span multiple dimensions, not just space. The data are compressed and they are fast to read/write in cloud-optimized storage (e.g. Google, Amazon, Azure). A dataset stored in Zarr typically represents one spatial scale — the scale at which the analysis or simulation was performed. However, it's easy to recreate the same dataset at multiple spatial scales, propagating the other non-spatial dimensions. We wrote a small package [`ndpyramid`](https://github.com/carbonplan/ndpyramid) to do that conversion, and to define [standard metadata](https://forum.image.sc/t/multiscale-arrays-v0-1/37930) for a multi-dimensional spatial pyramid. (In this conversion step we also reproject the data into [web mercator](https://en.wikipedia.org/wiki/Web_Mercator_projection), which is currently required by the rest of our toolkit. See below for more on relaxing this requirement.)

Second, we need to put the data on the screen. We wrote a small library for reading Zarr files in JavaScript called [`zarr-js`](https://github.com/freeman-lab/zarr-js), and we're using the [`regl`](https://github.com/regl-project/regl) library to render fetched chunks of binary data directly via WebGL as either gridded points or textures. Among possible alternatives, `regl` has worked well because it's simple, performant, and low-level, letting us avoid much of the boilerplate of raw WebGL, but without the complex scene rendering provided by [`three-js`](https://github.com/mrdoob/three.js/) and [`react-three-fiber`](https://github.com/pmndrs/react-three-fiber) — both of which are amazing tools, they just offer much more than what we need here.

Finally, because we're showing these data on a map, we need to render traditional map layers at the same time — roads, rivers, countries, etc.. For these layers we're continuing to use `mapbox-gl-js` with vector tiles, because parsing and rendering vector tiles is a hard problem and `mapbox-gl-js` solved it well.

## Putting it together

We've released an open-source library called [`@carbonplan/maps`](https://github.com/carbonplan/maps) that puts all these pieces together. It's a small set of React components for rendering data-driven gridded raster maps. Behind the scenes, it synchronizes data fetching via `zarr-js`, raster data rendering via `regl`, and vector rendering and interactive controls powered by `mapbox-gl-js`. The library handles all the tile math, selecting which chunks to load based on the current view. Everything is wired for reactivity — most map properties are controlled by React props, and the map will dynamically rerender when props change without thrashing the rendering loop.

For the simplest possible example, the following code renders a 2d map of global temperature.

```js
import { Map, Raster } from '@carbonplan/maps'
import { useColormap } from '@carbonplan/colormaps'

const colormap = useColormap('warm')

<Map>
  <Raster
    colormap={colormap}
    clim={[-20,30]}
    source={
      'https://storage.googleapis.com/carbonplan-share/testing/maps/2d/tavg'
    }
    variable={'tavg'}
    dimensions={['y', 'x']}
  />
</Map>
```

<MapDemo2d />

The source data is a Zarr group with the same temperature data encoded at multiple zoom levels. The file layout (with some files hidden for clarity) is as follows — note how the number of chunks doubles as the zoom level increases. All the necessary metadata is loaded from Zarr.

```
/
 ├── .zmetadata
 ├── 0
 │   ├── tavg
 │       └── 0.0
 ├── 1
 │   ├── tavg
 │       └── 0.0
 │       └── 0.1
 │       └── 1.0
 │       └── 1.1
 ├── 2
...
```

With the same component, we can just as easily render a 4d map where the third dimension is the month and the fourth dimension is temperature or precipitation (labeled “band” in this dataset).

```js
<Map>
  <Raster
    colormap={colormap}
    clim={[-20, 30]}
    source={
      'https://storage.googleapis.com/carbonplan-share/testing/maps/4d/tavg-prec-month'
    }
    variable={'climate'}
    dimensions={['band', 'month', 'y', 'x']}
    selector={{ band: 'tavg', month: 4 }}
  />
</Map>
```

<MapDemo4d />

In the above code sample we selected a single month and variable, but we could just as easily make those React state objects controlled by sliders, menus, etc. See the live [demo](https://maps.demo.carbonplan.org/) for a fully wired example of this functionality. Similarly, properties like the colormap, color range, and more can all be dynamic, with performant updating.

In more advanced settings, we might want extra control over rendering, including the ability to combine data across multiple layers with math. We've exposed a custom shader prop to make this easy. In this example, we render the average temperature over January and February by loading both months at once and averaging on the GPU, followed by a rescaling and colormap lookup. While this requires writing [shader code](<https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)>), it lets us combine data layers via arbitrarily complex math, with high performance and full control over what gets rendered to the screen.

```js
<Map>
  <Raster
    colormap={colormap}
    clim={[-20, 30]}
    source={
      'https://storage.googleapis.com/carbonplan-share/testing/maps/3d/tavg-month'
    }
    variable={'tavg'}
    dimensions={['month', 'y', 'x']}
    selector={{ month: [1, 2] }}
    frag={`
      float average = (month_1 + month_2) / 2.0
      float rescaled = (average - clim.x)/(clim.y - clim.x);
      gl_FragColor = texture2D(colormap, vec2(rescaled, 1.0));
    `}
  />
</Map>
```

## Comparisons

There are so many existing approaches to web maps, and we're grateful to, and eager to work well with, the rest of the ecosystem.

Both `mapbox-gl-js` itself and another library called [`deck.gl`](https://github.com/visgl/deck.gl) handle a much wider variety of data types than our library does, but we think ours handles gridded raster data more effectively, so in that sense they're highly complimentary. While we use `mapbox-gl-js` inside our library, and plan to continue doing so, we are restricted to using v1 because [Mapbox changed its licensing for v2](https://github.com/mapbox/mapbox-gl-js/blob/main/CHANGELOG.md#200). We are actively following the projects that have forked from Mapbox v1, as we may ultimately need to switch to using one of those, or build some of the same features ourselves.

One major limitation of `mapbox-gl-js` v1 is that it only supports the [web mercator projection](https://docs.mapbox.com/help/glossary/projection/). By building off of tools like [`d3-geo`](https://github.com/d3/d3-geo), we have prototyped rendering raster data with other map projections. However, to fully support other projections we also need to handle the vector tile rendering, which means either modifying or fully replacing our dependency on `mapbox-gl-js`. We see this as an important future direction, both because of the representational benefits of other map projections, and because it would prevent the need to store multiple copies of the same data (unprojected and projected), which is expensive for terabyte or petabyte scale climate data.

Another [effort to load Zarr in JavaScript](https://github.com/gzuidhof/zarr.js/) emerged around the same time we started `zarr-js`. That project is now a more full featured implementation of both Zarr reading and writing in the browser, but we continue to prefer our lighter-weight read-only library for our mapping use case. It'd be great to find some unification here, and the authors of that library have [expressed interest](https://github.com/gzuidhof/zarr.js/issues/69) in a lighter-weight, read-only package.

Finally, another recent project called [Viv](https://github.com/hms-dbmi/viv) renders large microscopy data stored as Zarr files in the browser. (It also renders data from a microscopy-oriented variant of TIFF called OME-TIFF). There are both similarities and important differences between rendering microscopy data and rendering maps of the world — even if it doesn't make sense to merge, we'd love to share learnings across the projects, and hopefully develop shared standards, especially involving multi-dimensional pyramids stored in Zarr.

## Next steps

We're just getting started. We used our library for a [production web map](https://carbonplan.org/research/forest-carbon) for the first time two weeks ago. We'll be building out the library further for our own use cases, and are planning to make it more robust — with validation, tests, etc. — alongside adding new features. It's in the early stages of development, so while we'll adhere to semantic versioning, you should expect frequent updates and breaking changes. We want to hear from folks interested in using the library for their own purposes, as we'd love to enable others — whether front-end developers looking to build new map experiences, or Python-wielding climate scientists wanting an easier way to share their datasets on the web.
